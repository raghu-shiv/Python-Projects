1- Introduction
In our current implementation of Farewheels App, we have assumed an ideal world where everything works successfully. However, in the real world, there are always unexpected errors. For example, it is possible that our connection to MongoDB drops out for whatever reason. So as a best practice, you should count for these unexpected situations and handle them properly, which means you should send a proper error message to the client and log the exception on the server. So later, you can look at the log and see what are some issues that are happening frequently and how you can improve them. So let me demonstrate a real world scenario where our MongoDB server dies. So here in the terminal, you can see I'm running the application with NodeMon and here's my other terminal window where I'm running MongoDaemon. It is the background service that is listening on port 27017. And here in Postman, I have a tab open to send a get request to API slash companies. So when we send this request, we get a 200 response. Beautiful. Now, back in MongoDB terminal, I'm going to stop this process. So control and C, MongoDB shut down. Let's see what happens when we send this request one more time. So this is hanging in there. After 30 seconds, we're going to see an error message in the terminal where we're running the application. Okay, here's the error message, unhandled, promise rejection. And here's the actual error. Failed to reconnect after 30 attempts with interval 1000 milliseconds. So by default, when you connect to MongoDB, if the connection cannot be established, MongoDB driver will attempt to reconnect 30 times with one second interval. Now, look at this warning, Deprecation warning. Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. So this means in the next version of Node, if we have an unhandled promise, this process will terminate, will end up here, and we will not be able to serve any other clients. Now in this particular demonstration, yes, I shut down our MongoDB server, so it wouldn't really matter if this process is live or not. But let's imagine in a real word scenario, our MongoDB server is going down for let's say one minute. And then it's going to come back up after one minute. With the current implementation, our Node process will terminate and will not be able to serve any other clients even after MongoDB re-starts. So we need to properly handle these scenarios. And that's what you're going to learn in this section.

2- Handling Rejected Promises
So now let's take the first step to handle this arrow properly. Whenever you see unhandled, promise rejection, that means you're using a promise, which means you're dealing with asynchronous code, that promise is rejected, but you have not handled the rejection properly. So let's go to our genres module. This is the handler for getting the list of genres. So here we have a promise that is returned here. We're awaiting that, but nowhere in this code, we have a try-catch blog to handle rejected promises. This implementation is the same as getting a promise calling then, but not calling catch to handle the rejections. So if you're using the promise syntax with then, we should always call catch to handle exceptions. If you're using asynchronous, you should always have try catch blocks. So here we need to put this code in a try block like this, and then add the catch block where we get the exception. Now here we need to send a proper response to the client. So response.status, we use the error code 500, which means internal server error. So something failed on the server, we don't know what. And then send a message like something failed. Now technically here, we should also log the exception, but we're going to look at that later. So let's improve this application step by step. Now, let's see how this new implementation works. So back in the terminal, I'm going to start MongoDB first, because if we don't start it and then run the application, look, we cannot connect to MongoDB. So initially, I want to be connected to MongoDB, and then I want to drop that connection somewhere in the middle. So let's stop this application. Now back to the other terminal window for MongoDB. Let's run MongoDB or MongoDame in one more time. Okay. MongoDB is listening. Now, let's run our Vidlion application. Now back to MongoDB terminal. I'm going to stop this process and then here in postman, I'm going to send a request to the genre's endpoint. This is going to take 30 seconds. So I'm going to pause the recording and come back. All right. This is what we get. So 500 internal server error, and this is our message. Now if you look at the terminal window for our application, you no longer see that unhandled promise rejection, which will result in the termination of this process in the future version of node.

3- Express Error Middleware
So in the last lecture, we took the first step to handle errors properly, but there is a problem in the current implementation. Let's say tomorrow we decide to change the message that we send to the client. With the current implementation, we have to go to every route handler where we have used this try-catch block and modify that message. So in a real-world situation, here we're going to log the exception. Again, if in the future we decide to change how we log the exception, we have to go back to several route handlers and make that change. So we want to move this logic for handling errors to somewhere central. So if in the future we want to make it change in how we handle errors, there is a single place we need to modify. So let's go to index.js. This is where we're registering our middleware functions. In Express, we have a special kind of middleware function called error middleware. We register that middleware function after all the existing middleware functions. So here we call app.use and pass a middleware function with three parameters request, response and next. But we also add the fourth argument here at the front. That's the exception or error that we catch somewhere else in the application. Now in this function, we add all the logic for handling errors in our application. So back to genres.js, I'm going to cut this logic from here and paste it here. Now back to genres.js one more time. Here in this catch block, we want to pass control to our error handling middleware function. So we add a new parameter here. Next we have seen this before. So we call next to pass control to the next middleware function in the request processing pipeline. We here in the catch block, we call nix and pass this exception as an argument. Now because in index.js, we registered this function after all the existing middleware functions, when we call next, we'll end up here. And the exception that we pass will be the first argument to this function. Now with this new implementation, we have a single place to handle errors. So if you want to make changes in the future, we only come back and modify this function. In a real world application, the logic for logging the exception might be several lines long. We don't want to add all that details in index.js. So in index.js, we just want to do orchestration. We want to do a high level arrangement. The details should be encapsulated in different modules. So I'm going to move this function, this middleware function, to a separate module. Back here, we have this middleware folder. Let's add a new file here, error.js. Back in index.js, I'm going to cut this function here. And in error.js, set module that exports to this function. So now we separated the details of error handling in a separate module. And this results in better separation of concerns. So in index.js, on the top, we need to load this module, const error. We set this to require, go to the middleware folder and load the error module. And finally, here, we call app.use and pass our error handling function here. Note that I'm not calling this function. I'm just passing a reference to this function. So now our application has better design. However, in genres.js, we have this tricatch block. And as you can tell, we have to repeat this in every route hand learning application. We have to add this catch exception. And here, we should call next. This is repetitive. So in the next lecture, I'm going to show you how to improve this implementation.

4- Removing Try Catch Blocks
So here in this route handler, we have this tricatch block. The problem with this implementation is that we have to repeat this tricatch block in every route handler. And also, this is adding extreme noise to the code and it's distracting us from the actual logic that belongs to this route handler. So ideally, we should move this high level code somewhere else to a single function. Something like this, let me show you. So let's define a function. Let's call this async middleware. And later you will know why I chose this name. So this function should have a template like this. So here we have the tricatch block. We're going to execute some code here and this code will vary from one route handler to another. Then we have the tricatch block that takes an exception and here we simply call next with this exception. So this is the template that we want to have in every route handler. The part that is different is only this part. So what if we pass a function as an argument here that is our route handler function, then we can call that here. So with this, we can simplify the code in this route handler. We no longer need the tricatch block and the next parameter. Now look at this async function. This anonymous function that we are passing as a route handler. So this is an async function and eventually we want to pass this function as an argument that is new function. Now because handler is an async function, we should await it. And because we have used await here, we should also mark this function as async. Okay. Now here as the second argument to the get method, we want to call async middleware and pass this anonymous function as an argument which we call handler. So let's call async middleware. We pass an argument which is an anonymous async function. Now there is a tiny issue here. Here in the tric block, this handler that we are calling needs two arguments, the request and the response. So look, this anonymous function is our handler, right? And this function has two parameters, request and response. So when calling it, we should pass the request and the response objects here. Now the issue we have here is that nowhere in this async middleware function, we have defined request, response and next. The only parameter in this function is a reference to another function which we call handler. So how do we get access to these three objects? Well, before I tell you how we get access to these objects, we need to look at a deeper issue. In the current implementation, we are calling async middleware function and passing this handler as an argument. So we're calling this function here. However, when defining an express route, we are not going to call our middleware or route handler functions. We simply pass a reference to a function. Let me clarify. So here I'm going to define another route, router.get, let's say another. So here we pass a route handler function, which takes two arguments, request and response and potentially next as well, right? So that goes to this code block. Note that here we're passing a function reference. We are not calling this function. In other words, we don't call it and pass some arguments here. It's the express framework that calls this function and passes these arguments at runtime. So this is the issue we have. In the current implementation, we are calling async middleware. We are not passing a reference to a function that takes these three parameters. So we need to make a small change in this function. We can keep everything here as is. But when we call this function, we can return a route handler function that looks like this. In other words, this function will be like a factory function. We call it and get a new function. That function is a route handler that looks like this and express can call that and pass these arguments at runtime. So here we need to return a route handler function. So that takes a request, response and next, like this. Now look, here we have access to these objects at runtime. Express is going to pass this for us. So we can move this code inside the body of this function. And then we can simply pass these arguments here. So let's cut this and put it here. Now in this function, we are awaiting the call to the handler. So we need to mark the calling function, which is this function as async. And we no longer need to apply this async here anymore. Because in this function, in async middleware, nowhere we are awaiting a promise. We're simply returning an async function. Okay? So this is unnecessary. We should delete it. And we're done. Let's see what happens. Let's review. So with the new implementation, we move the try catch block to a single place. We don't have to repeat it in every route handler. And this means the code in our route handlers will be more focused. We can see the actual logic that belongs to the route handler. And the way we achieve this was by defining this async middleware that takes a handler. So we call this async middleware here, pass our original route handler here. So we're passing a function reference. We call that handler. Now when we call this function, we return a standard express route handler. This route handler is an async function with three parameters. In the body of this function, we have a try catch block. And in the try block, we simply call the handler that we pass as an argument here. Now we don't want to have this async middleware hanging in the genres module. We want to put this in a separate module. So we can reuse it in multiple places. So in the middleware folder, I'm going to add a new file async. The JS. Now back in genres, the JS. Let's cut this code, move it here. And here we simply export this function. Simplify that. Now back in genres, the JS. On the top, we need to load this module. So const, let's call this async middleware. We set this to require from middleware folder async module. Now with this new implementation, we simply wrap each route handler with this async middleware. So we call async middleware and pass this route handler function as an argument.

5- Express Async Errors
So in the last lecture we defined as async middleware function. And by the way I noticed that I had a typo here, so here we should have module.exports. Now while this async middleware function solves the problem of repetitive tricatch blocks, the issue we have is that we have to remember to call it every time. And this also makes our code a little bit noisy. So in this lecture I'm going to show you a different approach. We're going to use an NPM module and this module will monkey patch our route handlers at runtime. So when we send a request to this endpoint, that module will wrap our route handler code inside something like this. Let me show you how that works. To open up a terminal and install, express dash async dash errors. Note that there's another module called express async error, but here we're working with express async errors. So let's install this again, note the version that is version 2.1.0. Now let's go to index.js. We need to load this module when the application starts. So we'll have a require of express async errors. That's all we have to do. We don't have to get the result and store it in a constant. Now back in genres.js, we can remove the call to async middleware and get back to our original route handler implementation, which is far simpler and cleaner. Similarly, I'm going to remove the second call to async middleware and finally on the top, I'm going to remove the required statement as well. Now let's test this and make sure it is functioning properly. So back in the terminal, I'm going to run Mongo Damien, beautiful. And then let's run our Vidley application suite. Now in postman, I'm going to get all the genres. So that endpoint is working. Now I'm going to stop MongoDB. So here in the MongoDB terminal, let's stop this and then send another request to the server. So send again, this is going to take a little while. All right, here's the response we were expecting. A 500 error with this message. So this verifies that this module that we installed properly moved control from a route handler to our error handling function. So you can see using express async errors module is very, very easy and this is my suggested approach for handling async errors in express route handlers. However, if this module doesn't work for your application for whatever reason, then you need to switch back to this other approach and use async middleware function.

6- Logging Errors
So this is our error middleware. Now as I told you before, in every enterprise application, we need to log the exceptions that are thrown in the application. So later we come back, look at the log and see what are the areas of the application that we can improve. So in this lecture, I'm going to introduce you to a very popular logging library called Winston. So here's Winston on NPM. The current version is 2.4 and you can see there have been over 6.5 million downloads over the last month. It's a very popular and feature rich library. So let's get started. Here in the terminal NPM install Winston. Again, note the version. So 2.4.0. Now let's go to index.js and configure Winston. So on the top, first we need to load this module. So require Winston and store it in this object, Winston. Now this Winston is the default logger that is exported from this module. We can also create a logger manually, but using the default logger is sufficient for a small to medium sized applications. You may need a custom logger only if you're building a really large complex application. And you want to have different loggers that behave differently in different parts of the application. So this logger object has what we call a transport. A transport is essentially a storage device for our logs. So Winston comes with a few core transports. They are console for login messages on the console file an HTTP for calling an HTTP endpoint for login messages. There are also plugins for Winston, there are other NPM modules for login messages in MongoDB and couch DB, which is another popular no SQL database. There's also a plugin for login messages in redis and logly, which is a very popular log analysis and monitoring service for enterprise applications. So this default logger that is exported from this module comes with one transport and that is for login messages in the console. But here I want to show you how to add another transport for login messages in a file. So here on the top, we call Winston.ad. Unfortunately, we don't have good intelligence here. Hopefully that will be improved in the future. So we pass Winston dot transport dot file. And as the second argument, we pass an object here, we set a property file name. Let's say log file dot log. Now back to our error middleware. When we get an exception, we can use Winston to log it. So on the top first we load Winston, constant Winston. We set that to require Winston. Now here we call Winston dot log to log the error. Now as the first argument, we need to set the logging level. Logging level determines the importance of the message we're going to log. So we have error, which is the most important login message. Then after that we have warn or warning. Then we have info or storing information in the log like connected to MongoDB. So these are not exceptions or errors. These are information about our application. We have verbose, debug for writing debugging information and silly. Now we can either pass the login level as an argument here, like error, and then set the error message in this case error dot message. Or we can use one of the helper methods. So instead of log, we can call error, then we don't need to pass the first argument. Now optionally we can also store metadata. So we can pass this error object and every property we have in this error object will also be stored in the log. You will see that in a second. Now to demonstrate this, let's go to genres.js. Here in the get genres route, I'm going to throw an error. So throw new error could not get the genres. So let's imagine somewhere in the application an error is thrown with the current implementation. Our error media will cache that exception. It will log it using Winston and return the 500 error to the client. Let's test this. So I'm going to run the application. Beautiful. Now back in postman, let's send a get request to the genres endpoint. All right, so here's our internal server error. Now if you look at the console, you can see the details of this exception. So here we have error because we used Winston dot error method. Here's the error message could not get the genres. And below that, we've got the stack trace, which is part of the error object. So this is the console transport, which is configured on the default logger. Now in our project, you can see here we have this new file log file dot log. Here we have a JSON object, but if you properties message, it could not get the genres. You've got stack, which represents the stack trace. And if you scroll to the far right, you can see level is set to error. And here's the time step when the error occurred. So with this level in the future, you can query the log file and perhaps extract only the errors or maybe only the information messages. So this is the big picture with simply called Winston dot error or one of the other helper methods and depending on the transports that we have configured, Winston will log the given message. In the next lecture, I'm going to show you how to log to MongoDB.

7- Logging to MongoDB
All right, now let me show you how to log messages to MongoDB. So we're going to install another NPM package that is Winston-MongoDB. So the current version is 4.0.0 and this is release candidate. There is an issue with this package, so I'm going to use an earlier, more stable version. NPM install, Winston-MongoDB. Let's install version 3.0.0. Make sure to use this exact version, otherwise what I'm going to show you in this lecture will not work with this release candidate version. So back in index.js, in the last lecture we added a file transport. Now we're going to add a MongoDB transport. First we need to go on the top. After reload, Winston, we need to load Winston-MongoDB. So require Winston-MongoDB. And here we don't care about what is exported from this module, we just need to require it. Okay? With this, we can come here and call Winston.ad. Winston.ad.transports.mongoDB. We pass an options object. There are a few properties here that you can look in the documentation. The one that you need to set is DB. So we set this to the connection string of our database. MongoDB, colon, slash slash, localhost, slash, vitally. Now in a real word scenario, you may want to separate your log from your operational database. That's a decision that varies from one environment to another. Here we're going to use the same database for logging our errors. All right, we're done with this. Now we don't need to make any other changes. So next time there is an error in the application, because we have another transport, Winston will automatically store our error in MongoDB. So let's run the application again. Send back in postman, send a request to the genre's endpoint. Done? Now, let's take a look at MongoDB Compass. Here's our Ville database. Let's refresh. We can see we have a new collection, log, and this is the message we log. So here's the timestamp. The level is set to error and here's the message could not get the genre's. Now this meta property is the metadata object that we passed as the second argument to this error method. So the first argument is the message, the second argument is metadata. So this error object has a few properties and all of them are stored in MongoDB. So here if you expand meta, you can see the message, name, as well as the stack trace. These are all the properties of the standard error object in JavaScript. Now in the last lecture, I talked about logging levels. So here are the standard logging levels. When adding a transport, you can also set the logging level for that transport. For example, back in index.js, maybe you only want to log the errors in MongoDB. You don't want to store information messages or debug messages. If that's the case, here in the options object, you set the database and next to that, you also set the level property. You set this to error. So with this, only error messages will be locked. Now if you set this to info, because info is the third logging level, that means only the error, warning and info messages will be locked. So nothing beyond info will be locked in MongoDB.

8- Uncaught Exceptions
Now, this arrow middleware that we have added here only catches errors that happen as part of request processing pipeline. So this is particular to express. If an error is thrown outside the context of express, this middleware will not be caught. Let me show you. So back in index.js, here after we configure Winston, I'm going to throw a new error, something failed during stardom. So this error is thrown outside the context of processing a request. It's outside the context of express. So now when I run this application, you will see that this error will crash the process and Winston will not be able to store it in the log. To verify this, I'm going to go to our log file, delete everything here, save. Now back in the terminal, the app is already crashed, but I want to do it one more time. So let's run it with node index.js. Okay, so you can see the process crashed. Here's our error, something failed during stardom. And if you look at log file, you can see there is nothing here. So if you deploy this application to production, your application is not working and there's no way for you to know what went wrong unless you have access to the console on the server. So in this lecture, I'm going to show you how to properly handle, unhandle exceptions in a node process. So this is at a higher level. It's not tied to express. So back in index.js, earlier in the course, you learned about this process object. This process object is an event emitter. Another event emitter is an object that can emit or publish events. And it gives us a method called on that we use to subscribe to an event. So here in node, we have a standard event called uncut exception. This event is raised when we have an exception in the node process, but nowhere we have handled that exception using a catch block. So make sure to spell it properly. Otherwise, what I'm going to show you in this lecture is not going to work. So if we have an uncut exception event in this process, we want to handle it using this function. This function takes the exception object. And here we can do a simple console log. We got an uncut exception. And then we can use Winston to log it. So Winston, that error, we pass exception that message, as well as the exception object, as the metadata object. Now back in the terminal, let's run this one more time. So here's our message we got an uncut exception. Note that this time, the process did not terminate because we caught the exception here. So the process terminates if we don't catch an exception. Okay. Now let's take a look at our log file. You can see our error message, something failed during startup. So this is how we handle uncut exceptions. In the next lecture, we're going to look at unhandled promise rejections.

9- Unhandled Promise Rejections
 So, in the last lecture you learned how to handle uncut exceptions. So if there is an exception in your application and you have not cut that exception using a catch block, you can subscribe to uncut exception of the process object and here you can log the error using Winston. However, this approach only works with synchronous code. In other words, if you have a promise somewhere and that promise is rejected, this code will not be executed. Let me show you. So here online 29, we are throwing an exception. Let's replace this with a rejected promise. So constant p, we set this to promise dot reject. Here we pass an error object, add a message like failed miserably. So imagine this promise represents the result of an asynchronous operation like a call to a database or a remote HTTP service and so on. So we have a rejected promise, the other tool jib before with promises, we either call then and then we should call catch to make sure to handle rejections or if we're using the async and await syntax. So we await the promise, but we should put this in a try catch block to catch the exceptions or rejections. In this code, we have a promise and I'm going to call then pass the simple callback console dot log done, but I'm not going to call catch. So we'll have an unhandled rejection. Let's see what happens. So back in the terminal, node index. JS. All right, look at this warning you have seen this before, unhandled promise rejection. And here's our error. Now with the current version of node, this unhandled promise rejection does not terminate the node process, but as you can see in this warning message in the future, promise rejections that are not handled will terminate the node JS process. So you can see this process is still running. We're connected to MongoDB. We're not in the terminal in the future when we have an unhandled promise rejection will end up here. So the process will crash. So now let me show you how to deal with unhandled promise rejections. This process object has another event similar to uncut exception called unhandled rejection. We can subscribe to that. So I'm going to select this code, duplicate it and change the event name to unhandled rejection. Again, note the spelling. And here we can change our message to regard an unhandled rejection. Okay. Now before we run the application, I want to show you in our log file, we only have one message and this came from catching an uncut exception. But when we ran the application a few seconds ago, we had an unhandled promise rejection. We could not log that, right? Now with this new code, when we handle this rejection will log it using Winston. So let's verify this. Back in the terminal, let's run the application again. All right. Here's our message. We got an unhandled rejection. Now if you look at the log, look here is our unhandled promise rejection. Now one last thing, whether you're dealing with an uncut exception or an unhandled rejection, as a best practice, you should terminate the node process. So you should exit here. Because at this point, your process can be in an unclean state. So as a best practice, we should terminate the process and restart it to make sure we start with a clean state. Now you might ask, if we terminate the process, how are we going to restart it in production? Well, there are tools for that, which we call process managers. And in the future, we're going to look at one of those tools. So here, I'm going to modify this code. We no longer need this console.log. We simply log the error using Winston and then exit the process with one. So as I told you before, zero means success. Anything but zero means failure. I'm going to make the same change to this other function done. Now there is also a different way to write this code. So instead of these three lines, we can call one of the helper methods in Winston. So Winston has this method, handle exceptions. Here we need to pass one or more transport objects. So new Winston dot transports dot file. We pass an options object here and set the file name to something like uncutexceptions.log. So note that when we call handle exceptions, we're specifying a different transport than the one we have configured with our default logger. Now you can use the same file name or a different file name that's internally up to you. We can also have multiple transports. One question you might have is whether you should log messages to a file or to a database like MongoDB. There are different opinions about this, but I personally believe you should use both transports because each transport has strengths and weaknesses. MongoDB or other databases is good for querying data. So if you want to create a client application for querying your log, it's much easier to query the data in MongoDB as opposed to a flat file like this. However, it is possible that your MongoDB server goes down or you cannot connect to it for whatever reason. In that case, it's better to use the file system because file system is always available. So this is handle exceptions. Now at the time of recording this video, this only works or uncutexceptions. So if you have unhandled rejections, this method is not going to log those exceptions. But I'm going to show you a trick to make that work. So I personally prefer to use handle exceptions method than manually subscribing to uncutexception event of the process object. I explained this so you know how this works internally. So let's remove this and just rely on Winston that handle exceptions. Now when we have an unhandled promise rejection, instead of this code, we can simply throw this exception and here we'll have an unhandled exception. So Winston will automatically catch that, log it in our file and then terminate the process.

10- Error Handling Recap


 All right, now let me give you a two-minute summary of everything you learn about error handling along with all the best practices. So in Express we have this error middleware which is basically a function with four arguments, error, request, response, and next. This function catches any errors in the request processing pipeline. So here we use Winston to log the error and then return a 500 or internal server error with a friendly message to the client. As I told you, this only works for errors that happen in the request processing pipeline. It will ignore anything outside the context of Express. So if something goes wrong during our application startup, this function is not going to be executed. So that's why in index.js we need to call Winston the handle exceptions to get any uncut exceptions and log them to a file. As I told you before at the time of recording this video, this only works with uncut exceptions. It will not work with unhandled promise rejections. But I know there is an open issue on the GitHub page. Somebody suggests that we need to add this feature to Winston and chances are it will be available in the future. So for now, we need to subscribe to unhandled rejection event of the process object. Here we simply throw an exception and then Winston will get that exception, log it, and terminate the process. So as a best practice when you're dealing with these kind of exceptions, you should terminate the node process because the process can be in an unclean state. So you should restart it with a clean state. In production, we use tools that we call process managers, which are responsible for automatically restarting a node process. So that's all about our handling and logging. Now if you look at the code in index.js, you can see this code is really growing out of hand. We have so much stuff happening here. And quite a few require statements on top of this file. This is not how we build enterprise applications. So over the next few lectures, I'm going to show you how to refactor this module and make it clean and maintainable.

11- Extracting Routes

 All right, so here's the code in index.js. The main issue we have here is lack of separation of concerns. There's so many things happening here, and that's why we have a large number of require statements on top of this module. Below that, you can see we have some code for handling and logging errors. After that, we've got something completely different, which is all about configuration. Then we move on to connecting to MongoDB, which is all about database. After that, we're setting up our routes and various middleware. These are different concerns. They should not be mixed together in one file or one module. In this module, we should only orchestrate these concerns. So the details of them should be moved to other modules. For example, the details of setting up routes, or the details of connecting to the database, they should be separated. So in this lecture, we're going to focus on extracting our routes into a separate module. So let's create a new folder called Startup. Here I'm going to add a new file, routes.js. And here we should export a function. So module.exports. We set this to a function. Now in this function, I'm going to add all the code for setting up our routes and other middleware. So back in index.js, I'm going to cut all these code and move it here. So look at the dependencies here. We have a dependency to app object to express all these routers like genres, customers, and so on. So back in index.js, on the top, online 16, this is how we create the app object. We should have a single instance of that in the entire application. In other words, we don't want to load express and then call it to create an app object in our new module. So we want to send a reference to this app to this new module. So this function should take app as an argument. Okay. Now back in index.js, here we have the app object. We can load our new module. That is startup slash routes. This returns a function. So we call it and pass the app object. That's it. It's all we have to do. Now let's clean up this module. So all these routers that we have imported here, like genres, customers, movies, and so on, all these should be moved to our new module because we have not referenced them anywhere else in this index module. So cut back here, paste them on the top. We have added most of the dependencies. We also need express and the error middleware. So we can load the express on the top, express, require, express. Now for the error middleware, I'm going to take it out of index.js because this is the only place you're referencing this middleware function. So back in index.js, let's scroll up. Here is our error middleware. Cut back in routes.js and let's add that here. Now back in index.js, you can see the code in this module is already much shorter. We don't have so many required statements anymore. And also the implementation is a little bit cleaner. Now one last thing, back to the routes module. We need to change the paths to these routers. Because the routes folder is not inside the start of folder. So anywhere we have period slash, I'm going to replace that with period period slash. So here I've selected these two characters. In VS code, we can enable multi cursor editing. So I'm holding down command and D on Mac. If you're using Windows, the shortcut is probably control D. So see I'm selecting multiple instances and then we can replace them all in one go. So period period slash done. Now as an exercise, I want you to go back to index.js and move all the database initialization code to a different module. You will see my solution in the next lecture.

12- Extracting the Db Logic
 So here in index.js, this is the only code we have for database initialization. So here in the startup folder, let's add a new file, db.js, just like the last lecture, here we're going to export a function. So module.exports, we set this to a function, and then move all the database initialization code right here. Now I'm going to make a few changes here. First of all, when we connect, I don't want to log this message on the console. I would rather log this as an informational message using Winston. So on the top, let's load Winston, require Winston. And then we replace console.log with Winston.info. Now also we should remove this catch method, because if we can't connect to MongoDB, we want to log that exception and terminate the process. With the current implementation, we're handling this rejected promise right here, and all we're doing is displaying this message on the console. So we're not logging this, we are not terminating the process. I added this earlier purely for demonstration purposes, but with the new implementation, we don't need this. So let's delete this. And finally we need to import Mongoose on the top. I'm going to take this out of index.js module. So back in index.js on the top, I'm going to remove this line for importing Mongoose. And then put it right here. So here's our database module. You can see the code is very clean, very short. We have a single responsibility. We don't have too many things mixed up together. And finally, we need to load this module in index.js. So here I'm going to call require startup slash DB. Here we get a function, so we call it. Now let's verify that with our current implementation, if we can't connect to the database during the application startup, that exception will be logged and the process will be terminated. So back in the terminal, I'm going to stop the MongoDB process and then back to the other terminal window, node index.js. So here's our exception, the process is terminated as we can see. And if you look at onCutExceptions.log, we can see the exception is logged here. Beautiful. So that's why I told you we should remove the catch method here and let our global error handler deal with that rejected promise. Here's your next exercise. I want you to go back to index.js and extract all the code for logging errors into a separate module called logging.js. You will see my solution next.

13- Extracting the Logging Logic
 All right, back in index.js, in this lecture, we're going to move all the code for setting up logging to a different module. So anything that is related to Winston and handling rejected promises. So back in the startup folder, let's add a new file, logging.js. Again, we export a function. And then back in index.js, take all this code for setting up Winston, cut it, and move it to log in the JS right here. Now here we need to import Winston as well as Winston-MongoDB. So let's go back to index.js on the top. This is where we're importing Winston and Winston-MongoDB cut and move them here. So you can see with every refactoring, our index.js module is getting shorter and cleaner. Now, I would also like to move this require statement for handling asynchronous errors in express. I would rather to put this in our login module, which is all about handling and logging errors. So let's require express async errors here as well. Now finally, we need to go back to index.js and load the login module require. Start up slash logging. Note that I put this first. So just in case we get an error and loading other modules to make sure to log that error and terminate the process. So we're done with this refactoring. Your next exercise is to move all the code for dealing with configuration for a separate module. So more specifically, I'm talking about these few lines here, where we look for essential configuration settings during the application start up.

14- Extracting the Config Logic
 All right, let's start by adding a new file in the start-up folder. So config.js. Again, we export a function. Now, back in index.js, we take all the code for looking for configuration settings into this new module. So here we have a dependency to the config module. We need to load it on the top. So I'm going to get this from index.js to clean up this module more. Okay, so if we don't have this configuration setting, we don't want to lock something on the console. We want to store this as a fatal error in our log. So instead of doing a console.error and process.exit, it's better to throw an exception and then our current infrastructure will cache that exception, log it and terminate the process. So we throw a new error and use the error message. Also as a best practice, always throw error objects instead of strings, even though you can do that in JavaScript. Because when you throw an error object, this stack trace will be available for you to see later. If you throw a string with the error message, you will not have the stack trace. Okay, so that's another best practice for you to know. Now finally, let's go back to index.js and load this new module. So require startup slash config. It's a function, so we call it. Look at the code in index.js. We only have 12 lines of code. And the last thing we can move here is the configuration of joy. Now we can move this to a module like validation.js or we can call that module API.js. Because we are using joy and the API layer. We use it to validate the input to our API. For this application, honestly, I don't have a strong opinion of what we should call that module. Let's call it validation.js. Maybe in the future, we'll come up with a better name. So go ahead, do this refactoring, and I will do the same next.

15- Extracting the Validation Logic
 So one more time in the startup folder we're going to add a new file. Let's call this validation.js. Here we export a function. Very simple function. And move this line for adding object ID to joy. To this new function. We also need to import joy here on the top. So back in index.js. Let's cut this and move it here. And finally, let's load this module in index.js. So require. Start a slash validation. Isn't this beautiful? Remember what we had before? I think we had 60 or 70 lines of code with really poor separation of concerns. Now with this new refactoring, we're doing only one thing. Setting up the application. The details of logging, the details of routes, the details of database and other aspects are delegated to other modules. This is single responsibility principle in practice. Now one last change I want to make here, to be consistent, is replacing this console.log with Winston. So let's load Winston. Require Winston. And then recall Winston.info. That's better. So back in the terminal, let's run the application. OK, here are the two info messages coming from Winston. The first one is for listening. And the second is connected to MongoDB.

16- Showing Unhandled Exceptions on the Console
 All right, one last thing before we finish this section. I noticed a tiny problem in the current implementation. If we take this application on a different machine and run node index.js, it terminates without telling us what happened. Now in the current implementation, we're using Winston to handle exceptions and we're using only a file transport. So if you look at this file, you can see why our application crashed. This is good for a production environment, but if you give this application to a new developer on the team and they run it, they have no idea what's going on. So we should add a console transport to display on handle exceptions on the console as well. So new Winston.transports.console. And here we can pass options. I'm gonna set a couple of properties here to make it easier to read these exceptions on the console. The first one is colorize, which we set to true and the other is pretty print. So with these two options, now let's go back to the terminal and run the application one more time. So we have this beautiful colorized error message. You can see the reason our application failed is because we have not defined JWT private key.

